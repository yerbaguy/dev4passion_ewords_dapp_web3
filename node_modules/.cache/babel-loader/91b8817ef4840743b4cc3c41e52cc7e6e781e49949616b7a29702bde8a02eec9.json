{"ast":null,"code":"import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, d as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, e as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, h as AlchemySubscription, j as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-f0af5585.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-50a90c21.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\nclass WebsocketBackfiller {\n  constructor(provider) {\n    this.provider = provider;\n    // TODO: Use HTTP provider to do backfill.\n    this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  }\n  /**\r\n   * Runs backfill for `newHeads` events.\r\n   *\r\n   * @param isCancelled Whether the backfill request is cancelled.\r\n   * @param previousHeads Previous head requests that were sent.\r\n   * @param fromBlockNumber The block number to start backfilling from.\r\n   * @returns A list of `newHeads` events that were sent since the last backfill.\r\n   */\n  getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throwIfCancelled(isCancelled);\n      const toBlockNumber = yield this.getBlockNumber();\n      throwIfCancelled(isCancelled);\n      // If there are no previous heads to fetch, return new heads since\n      // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n      if (previousHeads.length === 0) {\n        return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n      }\n      // If the last emitted event is too far back in the past, there's no need\n      // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n      // new heads.\n      const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\n      const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n      if (lastSeenBlockNumber <= minBlockNumber) {\n        return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n      }\n      // To capture all `newHeads` events, return all head events from the last\n      // seen block number to current + any of the previous heads that were re-orged.\n      const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\n      throwIfCancelled(isCancelled);\n      const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\n      throwIfCancelled(isCancelled);\n      return [...reorgHeads, ...intermediateHeads];\n    });\n  }\n  /**\r\n   * Runs backfill for `logs` events.\r\n   *\r\n   * @param isCancelled Whether the backfill request is cancelled.\r\n   * @param filter The filter object that accompanies a logs subscription.\r\n   * @param previousLogs Previous log requests that were sent.\r\n   * @param fromBlockNumber The block number to start backfilling from.\r\n   */\n  getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throwIfCancelled(isCancelled);\n      const toBlockNumber = yield this.getBlockNumber();\n      throwIfCancelled(isCancelled);\n      // If there are no previous logs to fetch, return new logs since\n      // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n      if (previousLogs.length === 0) {\n        return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n      }\n      // If the last emitted log is too far back in the past, there's no need\n      // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n      // worth of logs.\n      const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n      const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n      if (lastSeenBlockNumber < minBlockNumber) {\n        return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n      }\n      // Return all log events that have happened along with log events that have\n      // been removed due to a chain reorg.\n      const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\n      throwIfCancelled(isCancelled);\n      // All previous logs with a block number greater than the common ancestor\n      // were part of a re-org, so mark them as such.\n      const removedLogs = previousLogs.filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber).map(log => Object.assign(Object.assign({}, log), {\n        removed: true\n      }));\n      // If no common ancestor was found, start backfill from the oldest log's\n      // block number.\n      const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? fromHex(previousLogs[0].blockNumber) : commonAncestor.blockNumber;\n      let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\n      // De-dupe any logs that were already emitted.\n      addedLogs = addedLogs.filter(log => log && (fromHex(log.blockNumber) > commonAncestor.blockNumber || fromHex(log.logIndex) > commonAncestor.logIndex));\n      throwIfCancelled(isCancelled);\n      return [...removedLogs, ...addedLogs];\n    });\n  }\n  /**\r\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n   *\r\n   * @internal\r\n   */\n  setMaxBackfillBlock(newMax) {\n    this.maxBackfillBlocks = newMax;\n  }\n  /**\r\n   * Gets the current block number as a number.\r\n   *\r\n   * @private\r\n   */\n  getBlockNumber() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const blockNumberHex = yield this.provider.send('eth_blockNumber');\n      return fromHex(blockNumberHex);\n    });\n  }\n  /**\r\n   * Gets all `newHead` events in the provided range. Note that the returned\r\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n   * that were part of a re-org.\r\n   *\r\n   * @private\r\n   */\n  getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (fromBlockInclusive >= toBlockExclusive) {\n        return [];\n      }\n      const batchParts = [];\n      for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n        batchParts.push({\n          method: 'eth_getBlockByNumber',\n          params: [toHex(i), false]\n        });\n      }\n      // TODO: just fire off each send() separately since we're no longer batching:\n      // TODO: handle errors\n      const batchedBlockHeads = yield this.provider.sendBatch(batchParts);\n      const blockHeads = batchedBlockHeads.reduce((acc, batch) => acc.concat(batch), []);\n      return blockHeads.map(toNewHeadsEvent);\n    });\n  }\n  /**\r\n   * Returns all heads that were part of a reorg event.\r\n   *\r\n   * @private\r\n   */\n  getReorgHeads(isCancelled, previousHeads) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = [];\n      // Iterate from the most recent head backwards in order to find the first\n      // block that was part of a re-org.\n      for (let i = previousHeads.length - 1; i >= 0; i--) {\n        const oldEvent = previousHeads[i];\n        const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\n        throwIfCancelled(isCancelled);\n        // If the hashes match, then current head in the iteration was not re-orged.\n        if (oldEvent.hash === blockHead.hash) {\n          break;\n        }\n        result.push(toNewHeadsEvent(blockHead));\n      }\n      return result.reverse();\n    });\n  }\n  /**\r\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n   * block information for the provided block number.\r\n   *\r\n   * @private\r\n   */\n  getBlockByNumber(blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.provider.send('eth_getBlockByNumber', [toHex(blockNumber), false]);\n    });\n  }\n  /**\r\n   * Given a list of previous log events, finds the common block number from the\r\n   * logs that matches the block head.\r\n   *\r\n   * This can be used to identify which logs are part of a re-org.\r\n   *\r\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n   *\r\n   * @private\r\n   */\n  getCommonAncestor(isCancelled, previousLogs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Iterate from the most recent head backwards in order to find the first\n      // block that was part of a re-org.\n      let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\n      throwIfCancelled(isCancelled);\n      for (let i = previousLogs.length - 1; i >= 0; i--) {\n        const oldLog = previousLogs[i];\n        // Ensure that updated blocks are fetched every time the log's block number\n        // changes.\n        if (oldLog.blockNumber !== blockHead.number) {\n          blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\n        }\n        // Since logs are ordered in ascending order, the first log that matches\n        // the hash should be the largest logIndex.\n        if (oldLog.blockHash === blockHead.hash) {\n          return {\n            blockNumber: fromHex(oldLog.blockNumber),\n            logIndex: fromHex(oldLog.logIndex)\n          };\n        }\n      }\n      return {\n        blockNumber: Number.NEGATIVE_INFINITY,\n        logIndex: Number.NEGATIVE_INFINITY\n      };\n    });\n  }\n  /**\r\n   * Gets all `logs` events in the provided range. Note that the returned logs\r\n   * do not include removed logs.\r\n   *\r\n   * @private\r\n   */\n  getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (fromBlockInclusive >= toBlockExclusive) {\n        return [];\n      }\n      const rangeFilter = Object.assign(Object.assign({}, filter), {\n        fromBlock: toHex(fromBlockInclusive),\n        toBlock: toHex(toBlockExclusive - 1)\n      });\n      return this.provider.send('eth_getLogs', [rangeFilter]);\n    });\n  }\n}\nfunction toNewHeadsEvent(head) {\n  const result = Object.assign({}, head);\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\nfunction dedupeNewHeads(events) {\n  return dedupe(events, event => event.hash);\n}\nfunction dedupeLogs(events) {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\nfunction dedupe(items, getKey) {\n  const keysSeen = new Set();\n  const result = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\nconst CANCELLED = new Error('Cancelled');\nfunction throwIfCancelled(isCancelled) {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\nclass AlchemyWebSocketProvider extends WebSocketProvider {\n  /** @internal */\n  constructor(config, wsConstructor) {\n    var _a;\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\n    const protocol = `alchemy-sdk-${VERSION}`;\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\n      wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\n    });\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws, ethersNetwork);\n    this._events = [];\n    // In the case of a WebSocket reconnection, all subscriptions are lost and we\n    // create new ones to replace them, but we want to create the illusion that\n    // the original subscriptions persist. Thus, maintain a mapping from the\n    // \"virtual\" subscription ids which are visible to the consumer to the\n    // \"physical\" subscription ids of the actual connections. This terminology is\n    // borrowed from virtual and physical memory, which has a similar mapping.\n    /** @internal */\n    this.virtualSubscriptionsById = new Map();\n    /** @internal */\n    this.virtualIdsByPhysicalId = new Map();\n    /**\r\n     * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n     * messages. To allow backfilling, track all messages that are emitted.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.handleMessage = event => {\n      const message = JSON.parse(event.data);\n      if (!isSubscriptionEvent(message)) {\n        return;\n      }\n      const physicalId = message.params.subscription;\n      const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n      if (!virtualId) {\n        return;\n      }\n      const subscription = this.virtualSubscriptionsById.get(virtualId);\n      if (subscription.method !== 'eth_subscribe') {\n        return;\n      }\n      switch (subscription.params[0]) {\n        case 'newHeads':\n          {\n            const newHeadsSubscription = subscription;\n            const newHeadsMessage = message;\n            const {\n              isBackfilling,\n              backfillBuffer\n            } = newHeadsSubscription;\n            const {\n              result\n            } = newHeadsMessage.params;\n            if (isBackfilling) {\n              addToNewHeadsEventsBuffer(backfillBuffer, result);\n            } else if (physicalId !== virtualId) {\n              // In the case of a re-opened subscription, ethers will not emit the\n              // event, so the SDK has to.\n              this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n            } else {\n              // Ethers subscription mapping will emit the event, just store it.\n              this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n            }\n            break;\n          }\n        case 'logs':\n          {\n            const logsSubscription = subscription;\n            const logsMessage = message;\n            const {\n              isBackfilling,\n              backfillBuffer\n            } = logsSubscription;\n            const {\n              result\n            } = logsMessage.params;\n            if (isBackfilling) {\n              addToLogsEventsBuffer(backfillBuffer, result);\n            } else if (virtualId !== physicalId) {\n              this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n            } else {\n              this.rememberEvent(virtualId, result, getLogsBlockNumber);\n            }\n            break;\n          }\n      }\n    };\n    /**\r\n     * When the websocket connection reopens:\r\n     *\r\n     * 1. Resubscribe to all existing subscriptions and start backfilling\r\n     * 2. Restart heart beat.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.handleReopen = () => {\n      this.virtualIdsByPhysicalId.clear();\n      const {\n        cancel,\n        isCancelled\n      } = makeCancelToken();\n      this.cancelBackfill = cancel;\n      for (const subscription of this.virtualSubscriptionsById.values()) {\n        void (() => __awaiter(this, void 0, void 0, function* () {\n          try {\n            yield this.resubscribeAndBackfill(isCancelled, subscription);\n          } catch (error) {\n            if (!isCancelled()) {\n              console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\n            }\n          }\n        }))();\n      }\n      this.startHeartbeat();\n    };\n    /**\r\n     * Cancels the heartbeat and any pending backfills being performed. This is\r\n     * called when the websocket connection goes down or is disconnected.\r\n     *\r\n     * This is a field arrow function in order to preserve `this` context when\r\n     * passing the method as an event listener.\r\n     *\r\n     * @internal\r\n     */\n    this.stopHeartbeatAndBackfill = () => {\n      if (this.heartbeatIntervalId != null) {\n        clearInterval(this.heartbeatIntervalId);\n        this.heartbeatIntervalId = undefined;\n      }\n      this.cancelBackfill();\n    };\n    this.apiKey = apiKey;\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n  /**\r\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n   *\r\n   * This override allows the SDK to set the provider's network to values not\r\n   * yet supported by ethers.js.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  static getNetwork(network) {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetwork(network);\n  }\n  /**\r\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n   *\r\n   * @param eventName Event to subscribe to\r\n   * @param listener The listener function to call when the event is triggered.\r\n   * @override\r\n   * @public\r\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName, listener) {\n    return this._addEventListener(eventName, listener, false);\n  }\n  /**\r\n   * Overridden implementation of ethers that includes Alchemy based\r\n   * subscriptions. Adds a listener to the triggered for only the next\r\n   * {@link eventName} event, after which it will be removed.\r\n   *\r\n   * @param eventName Event to subscribe to\r\n   * @param listener The listener function to call when the event is triggered.\r\n   * @override\r\n   * @public\r\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName, listener) {\n    return this._addEventListener(eventName, listener, true);\n  }\n  /**\r\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n   * listener is provided, all listeners for the event will be removed.\r\n   *\r\n   * @param eventName Event to unlisten to.\r\n   * @param listener The listener function to remove.\r\n   * @override\r\n   * @public\r\n   */\n  off(eventName, listener) {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n  /**\r\n   * Remove all listeners for the provided {@link eventName} event. If no event\r\n   * is provided, all events and their listeners are removed.\r\n   *\r\n   * @param eventName The event to remove all listeners for.\r\n   * @override\r\n   * @public\r\n   */\n  removeAllListeners(eventName) {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n  /**\r\n   * Returns the number of listeners for the provided {@link eventName} event. If\r\n   * no event is provided, the total number of listeners for all events is returned.\r\n   *\r\n   * @param eventName The event to get the number of listeners for.\r\n   * @public\r\n   * @override\r\n   */\n  listenerCount(eventName) {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n  /**\r\n   * Returns an array of listeners for the provided {@link eventName} event. If\r\n   * no event is provided, all listeners will be included.\r\n   *\r\n   * @param eventName The event to get the listeners for.\r\n   * @public\r\n   * @override\r\n   */\n  listeners(eventName) {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n  /**\r\n   * Overrides the method in `BaseProvider` in order to properly format the\r\n   * Alchemy subscription events.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  _addEventListener(eventName, listener, once) {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n  /**\r\n   * Overrides the `_startEvent()` method in ethers.js's\r\n   * {@link WebSocketProvider} to include additional alchemy methods.\r\n   *\r\n   * @param event\r\n   * @override\r\n   * @internal\r\n   */\n  _startEvent(event) {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n  /**\r\n   * Overridden from ethers.js's {@link WebSocketProvider}\r\n   *\r\n   * Modified in order to add mappings for backfilling.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  _subscribe(tag, param, processFunc, event) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let subIdPromise = this._subIds[tag];\n      // BEGIN MODIFIED CODE\n      const startingBlockNumber = yield this.getBlockNumber();\n      // END MODIFIED CODE\n      if (subIdPromise == null) {\n        subIdPromise = Promise.all(param).then(param => {\n          return this.send('eth_subscribe', param);\n        });\n        this._subIds[tag] = subIdPromise;\n      }\n      const subId = yield subIdPromise;\n      // BEGIN MODIFIED CODE\n      const resolvedParams = yield Promise.all(param);\n      this.virtualSubscriptionsById.set(subId, {\n        event: event,\n        method: 'eth_subscribe',\n        params: resolvedParams,\n        startingBlockNumber,\n        virtualId: subId,\n        physicalId: subId,\n        sentEvents: [],\n        isBackfilling: false,\n        backfillBuffer: []\n      });\n      this.virtualIdsByPhysicalId.set(subId, subId);\n      // END MODIFIED CODE\n      this._subs[subId] = {\n        tag,\n        processFunc\n      };\n    });\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @internal\r\n   * @override\r\n   */\n  emit(eventName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n      const stopped = [];\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n        result = true;\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n        return true;\n      });\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n  /** @internal */\n  sendBatch(parts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let nextId = 0;\n      const payload = parts.map(_ref => {\n        let {\n          method,\n          params\n        } = _ref;\n        return {\n          method,\n          params,\n          jsonrpc: '2.0',\n          id: `alchemy-sdk:${nextId++}`\n        };\n      });\n      const response = yield this.sendBatchConcurrently(payload);\n      const errorResponse = response.find(r => !!r.error);\n      if (errorResponse) {\n        throw new Error(errorResponse.error.message);\n      }\n      // The ids are ascending numbers because that's what Payload Factories do.\n      return response.sort((r1, r2) => r1.id - r2.id).map(r => r.result);\n    });\n  }\n  /** @override */\n  destroy() {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n  /**\r\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n   * current api key is the default key.\r\n   *\r\n   * @override\r\n   */\n  isCommunityResource() {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n   *\r\n   * This method is copied over directly in order to support Alchemy's\r\n   * subscription type by allowing the provider to properly stop Alchemy's\r\n   * subscription events.\r\n   *\r\n   * @internal\r\n   */\n  _stopEvent(event) {\n    let tag = event.tag;\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n  /** @internal */\n  addSocketListeners() {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n  /** @internal */\n  removeSocketListeners() {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n  /**\r\n   * Reopens the backfill based on\r\n   *\r\n   * @param isCancelled\r\n   * @param subscription\r\n   * @internal\r\n   */\n  resubscribeAndBackfill(isCancelled, subscription) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        virtualId,\n        method,\n        params,\n        sentEvents,\n        backfillBuffer,\n        startingBlockNumber\n      } = subscription;\n      subscription.isBackfilling = true;\n      backfillBuffer.length = 0;\n      try {\n        const physicalId = yield this.send(method, params);\n        throwIfCancelled(isCancelled);\n        subscription.physicalId = physicalId;\n        this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n        switch (params[0]) {\n          case 'newHeads':\n            {\n              const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\n              throwIfCancelled(isCancelled);\n              const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n              events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n              break;\n            }\n          case 'logs':\n            {\n              const filter = params[1] || {};\n              const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\n              throwIfCancelled(isCancelled);\n              const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n              events.forEach(event => this.emitLogsEvent(virtualId, event));\n              break;\n            }\n          default:\n            break;\n        }\n      } finally {\n        subscription.isBackfilling = false;\n        backfillBuffer.length = 0;\n      }\n    });\n  }\n  /** @internal */\n  emitNewHeadsEvent(virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n  /** @internal */\n  emitLogsEvent(virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n  /**\r\n   * Emits an event to consumers, but also remembers it in its subscriptions's\r\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n   * and needs to be reconnected.\r\n   *\r\n   * @internal\r\n   */\n  emitAndRememberEvent(virtualId, result, getBlockNumber) {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n  /** @internal */\n  rememberEvent(virtualId, result, getBlockNumber) {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\n  }\n  /** @internal */\n  emitGenericEvent(subscription, result) {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n  /**\r\n   * Starts a heartbeat that pings the websocket server periodically to ensure\r\n   * that the connection stays open.\r\n   *\r\n   * @internal\r\n   */\n  startHeartbeat() {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch (_a) {\n        this._websocket.reconnect();\n      }\n    }), HEARTBEAT_INTERVAL);\n  }\n  /**\r\n   * This method sends the batch concurrently as individual requests rather than\r\n   * as a batch, which was the original implementation. The original batch logic\r\n   * is preserved in this implementation in order for faster porting.\r\n   *\r\n   * @param payload\r\n   * @internal\r\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  sendBatchConcurrently(payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.all(payload.map(req => this.send(req.method, req.params)));\n    });\n  }\n  /** @internal */\n  customStartEvent(event) {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const {\n        fromAddress,\n        toAddress,\n        hashesOnly\n      } = event;\n      void this._subscribe(event.tag, [AlchemySubscription.PENDING_TRANSACTIONS, {\n        fromAddress,\n        toAddress,\n        hashesOnly\n      }], this.emitProcessFn(event), event);\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const {\n        addresses,\n        includeRemoved,\n        hashesOnly\n      } = event;\n      void this._subscribe(event.tag, [AlchemySubscription.MINED_TRANSACTIONS, {\n        addresses,\n        includeRemoved,\n        hashesOnly\n      }], this.emitProcessFn(event), event);\n    } else if (event.type === 'block') {\n      void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\n    } else if (event.type === 'filter') {\n      void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\n    }\n  }\n  /** @internal */\n  emitProcessFn(event) {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result => this.emit({\n          method: AlchemySubscription.PENDING_TRANSACTIONS,\n          fromAddress: event.fromAddress,\n          toAddress: event.toAddress,\n          hashesOnly: event.hashesOnly\n        }, result);\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result => this.emit({\n          method: AlchemySubscription.MINED_TRANSACTIONS,\n          addresses: event.addresses,\n          includeRemoved: event.includeRemoved,\n          hashesOnly: event.hashesOnly\n        }, result);\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider.off()`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @private\r\n   */\n  _off(eventName, listener) {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n    const stopped = [];\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n    return this;\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @private\r\n   */\n  _removeAllListeners(eventName) {\n    let stopped = [];\n    if (eventName == null) {\n      stopped = this._events;\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n    return this;\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @private\r\n   */\n  _listenerCount(eventName) {\n    if (!eventName) {\n      return this._events.length;\n    }\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n  /**\r\n   * DO NOT MODIFY.\r\n   *\r\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n   *\r\n   * This method is copied over directly in order to implement Alchemy's unique\r\n   * subscription types. The only difference is that this method calls\r\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n   * order to parse the Alchemy subscription event.\r\n   *\r\n   * @private\r\n   */\n  _listeners(eventName) {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => event.tag === eventTag).map(event => event.listener);\n  }\n}\nfunction getWebsocketConstructor() {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\nfunction isNodeEnvironment() {\n  return typeof process !== 'undefined' && process != null && process.versions != null && process.versions.node != null;\n}\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken() {\n  let cancelled = false;\n  return {\n    cancel: () => cancelled = true,\n    isCancelled: () => cancelled\n  };\n}\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\nfunction withBackoffRetries(f, retryCount) {\n  let shouldRetry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => true;\n  return __awaiter(this, void 0, void 0, function* () {\n    let nextWaitTime = 0;\n    let i = 0;\n    while (true) {\n      try {\n        return yield f();\n      } catch (error) {\n        i++;\n        if (i >= retryCount || !shouldRetry(error)) {\n          throw error;\n        }\n        yield delay(nextWaitTime);\n        if (!shouldRetry(error)) {\n          throw error;\n        }\n        nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n      }\n    }\n  });\n}\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction withTimeout(promise, ms) {\n  return Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))]);\n}\nfunction getNewHeadsBlockNumber(event) {\n  return fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n  return fromHex(event.blockNumber);\n}\nfunction isResponse(message) {\n  return Array.isArray(message) || message.jsonrpc === '2.0' && message.id !== undefined;\n}\nfunction isSubscriptionEvent(message) {\n  return !isResponse(message);\n}\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\nexport { AlchemyWebSocketProvider };","map":{"version":3,"mappings":"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","names":["MAX_BACKFILL_BLOCKS","WebsocketBackfiller","constructor","provider","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","toBlockNumber","getBlockNumber","length","getHeadEventsInRange","Math","max","maxBackfillBlocks","lastSeenBlockNumber","fromHex","number","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","filter","previousLogs","getLogsInRange","blockNumber","commonAncestor","getCommonAncestor","removedLogs","log","map","Object","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","send","toBlockExclusive","batchParts","i","push","method","params","toHex","batchedBlockHeads","sendBatch","blockHeads","reduce","acc","batch","concat","toNewHeadsEvent","result","oldEvent","blockHead","getBlockByNumber","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","items","getKey","keysSeen","Set","forEach","item","key","has","add","CANCELLED","Error","HEARTBEAT_INTERVAL","HEARTBEAT_WAIT_TIME","BACKFILL_TIMEOUT","BACKFILL_RETRIES","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","WebSocketProvider","wsConstructor","apiKey","AlchemyProvider","getApiKey","config","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","protocol","ws","SturdyWebSocket","url","getWebsocketConstructor","ethersNetwork","EthersNetwork","Map","message","JSON","parse","data","isSubscriptionEvent","physicalId","subscription","virtualId","virtualIdsByPhysicalId","get","virtualSubscriptionsById","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","addToNewHeadsEventsBuffer","emitAndRememberEvent","getNewHeadsBlockNumber","rememberEvent","logsSubscription","logsMessage","addToLogsEventsBuffer","getLogsBlockNumber","clear","cancel","makeCancelToken","cancelBackfill","values","__awaiter","resubscribeAndBackfill","error","console","startHeartbeat","heartbeatIntervalId","clearInterval","undefined","backfiller","addSocketListeners","noop","getNetwork","CustomNetworks","getNetworkFromEthers","on","eventName","listener","_addEventListener","once","off","isAlchemyEvent","_off","removeAllListeners","_removeAllListeners","listenerCount","_listenerCount","listeners","_listeners","verifyAlchemyEventName","EthersEvent","getAlchemyEventTag","_events","_startEvent","customLogicTypes","ALCHEMY_EVENT_TYPES","includes","type","customStartEvent","_subscribe","tag","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","then","subId","resolvedParams","set","sentEvents","_subs","emit","args","stopped","eventTag","setTimeout","apply","_stopEvent","parts","nextId","payload","jsonrpc","id","response","sendBatchConcurrently","errorResponse","find","r","sort","r1","r2","destroy","removeSocketListeners","stopHeartbeatAndBackfill","isCommunityResource","DEFAULT_ALCHEMY_API_KEY","e","_websocket","addEventListener","handleMessage","handleReopen","removeEventListener","backfillEvents","withBackoffRetries","withTimeout","emitNewHeadsEvent","emitLogsEvent","emitGenericEvent","addToPastEventsBuffer","emitFunction","emitProcessFn","setInterval","_a","reconnect","req","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","fromAddress","toAddress","hashesOnly","AlchemySubscription","PENDING_TRANSACTIONS","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","addresses","includeRemoved","MINED_TRANSACTIONS","_getFilter","BigNumber","from","toNumber","_emitted","block","formatter","filterLog","found","isNodeEnvironment","require","w3cwebsocket","WebSocket","process","versions","node","cancelled","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","f","retryCount","shouldRetry","nextWaitTime","delay","min","ms","resolve","promise","race","_","reject","isResponse","Array","isArray","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","splice"],"sources":["/Users/bartosz/Documents/react-dapps/dev4passion_eword_web3/client/node_modules/alchemy-sdk/src/internal/websocket-backfiller.ts","/Users/bartosz/Documents/react-dapps/dev4passion_eword_web3/client/node_modules/alchemy-sdk/src/api/alchemy-websocket-provider.ts"],"sourcesContent":["import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: just fire off each send() separately since we're no longer batching:\n    // TODO: handle errors\n    const batchedBlockHeads = await this.provider.sendBatch(batchParts);\n    const blockHeads = batchedBlockHeads.reduce(\n      (acc, batch) => acc.concat(batch),\n      []\n    );\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    const response = await this.sendBatchConcurrently(payload);\n    const errorResponse = response.find(r => !!r.error);\n    if (errorResponse) {\n      throw new Error(errorResponse.error!.message);\n    }\n    // The ids are ascending numbers because that's what Payload Factories do.\n    return response\n      .sort((r1, r2) => (r1.id as number) - (r2.id as number))\n      .map(r => r.result);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<JsonRpcResponse[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\ninterface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}